import{_ as f}from"./ValaxyMain.vue_vue_type_style_index_0_lang.CF3jKIAV.js";import{d as b,a as v,u as J}from"./chunks/vue-router.0fijYp3S.js";import{a2 as M,a3 as t,a4 as s,a5 as l,a6 as a,a7 as k,B as y,a1 as V,D as g}from"./framework.CL_twgqk.js";import"./app.DJJRq6_7.js";import"./chunks/dayjs.BFInjCTz.js";import"./chunks/vue-i18n.CRimy4L_.js";import"./chunks/pinia.KHo6empO.js";/* empty css                    */import"./chunks/@vueuse/motion.DON3upiQ.js";import"./chunks/nprogress.DUFFUuWH.js";import"./YunComment.vue_vue_type_style_index_0_lang.lpZGJo7w.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.7-8ddEp8.js";import"./post.D4SLBNdn.js";const P=b("/posts/013-jvm-memory-model",async u=>JSON.parse('{"title":"JVM 内存模型","titleTemplate":"%s - yuier","description":"","frontmatter":{"title":"JVM 内存模型","titleTemplate":"%s - yuier","date":"2025-11-14 15:00:47","updated":"2025-11-14 15:00:47","author":"yuier","categories":["JVM"],"tags":["JVM","Java","八股文"],"cover":null,"hide":"index"},"headers":[],"relativePath":"pages/posts/013-jvm-memory-model.md","lastUpdated":1772277401000}'),{lazy:(u,r)=>u.name===r.name}),F={__name:"013-jvm-memory-model",setup(u,{expose:r}){const{data:o}=P(),d=J(),p=v(),i=Object.assign(p.meta.frontmatter||{},o.value?.frontmatter||{});return d.currentRoute.value.data=o.value,g("valaxy:frontmatter",i),globalThis.$frontmatter=i,r({frontmatter:{title:"JVM 内存模型",titleTemplate:"%s - yuier",date:"2025-11-14 15:00:47",updated:"2025-11-14 15:00:47",author:"yuier",categories:["JVM"],tags:["JVM","Java","八股文"],cover:null,hide:"index"}}),(e,n)=>{const m=f;return V(),M(m,{frontmatter:y(i)},{"main-content-md":t(()=>[n[0]||(n[0]=l("div",{class:"language-text max-h-900px"},[l("button",{title:"Copy code",class:"copy"}),l("span",{class:"lang"},"text"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",null,"+--------------------------------------------------+")]),a(`
`),l("span",{class:"line"},[l("span",null,"|                JVM 运行时数据区                  |")]),a(`
`),l("span",{class:"line"},[l("span",null,"+----------------------+---------------------------+")]),a(`
`),l("span",{class:"line"},[l("span",null,"| 线程私有             | 线程共享                  |")]),a(`
`),l("span",{class:"line"},[l("span",null,"|----------------------|---------------------------|")]),a(`
`),l("span",{class:"line"},[l("span",null,"| • 程序计数器         | • 堆（Heap）              |")]),a(`
`),l("span",{class:"line"},[l("span",null,"| • 虚拟机栈           |   - 新生代（Eden, S0, S1）|")]),a(`
`),l("span",{class:"line"},[l("span",null,"| • 本地方法栈         |   - 老年代                |")]),a(`
`),l("span",{class:"line"},[l("span",null,"|                      | • 方法区（Metaspace）     |")]),a(`
`),l("span",{class:"line"},[l("span",null,"+----------------------+---------------------------+")]),a(`
`),l("span",{class:"line"},[l("span")]),a(`
`),l("span",{class:"line"},[l("span",null,"+--------------------------------------------------+")]),a(`
`),l("span",{class:"line"},[l("span",null,"|               直接内存（Direct Memory）          |")]),a(`
`),l("span",{class:"line"},[l("span",null,"|（不属于 JVM 规范定义，但常被使用）               |")]),a(`
`),l("span",{class:"line"},[l("span",null,"+--------------------------------------------------+")])])]),l("button",{class:"code-block-unfold-btn"})],-1)),k(" more "),n[1]||(n[1]=l("h2",{id:"堆",tabindex:"-1"},[a("堆 "),l("a",{class:"header-anchor",href:"#堆","aria-label":'Permalink to "堆"'},"​")],-1)),n[2]||(n[2]=l("p",null,"最大、最重要的内存区域",-1)),n[3]||(n[3]=l("p",null,"存放对象实例、数组等。几乎所有的对象都在堆上分配（逃逸分析优化后可能栈上分配）。所有线程共享。",-1)),n[4]||(n[4]=l("p",null,"特点",-1)),n[5]||(n[5]=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"特性"),l("th",null,"说明")])]),l("tbody",null,[l("tr",null,[l("td",null,"线程共享"),l("td",null,"所有线程均可访问堆中的对象")]),l("tr",null,[l("td",null,"动态分配"),l("td",null,"对象在运行时动态创建，大小不固定")]),l("tr",null,[l("td",null,"自动管理"),l("td",null,"由 JVM 的垃圾回收器（GC）自动回收不再使用的对象")]),l("tr",null,[l("td",null,"可扩展"),l("td",null,"可通过 -Xms / -Xmx 设置初始和最大堆大小")]),l("tr",null,[l("td",null,"物理不连续"),l("td",null,"逻辑上连续，物理上可以是不连续的内存空间")])])],-1)),n[6]||(n[6]=l("p",null,"堆是垃圾收集器进行GC的最重要的内存区域",-1)),n[7]||(n[7]=l("h3",{id:"内部结构",tabindex:"-1"},[a("内部结构 "),l("a",{class:"header-anchor",href:"#内部结构","aria-label":'Permalink to "内部结构"'},"​")],-1)),n[8]||(n[8]=l("p",null,"Java 堆可以分为：新生代（Eden区、S0区、S1区）和 老年代。",-1)),n[9]||(n[9]=l("ul",null,[l("li",null,[l("p",null,"在绝大多数情况下，对象首先分配在eden区")]),l("li",null,[l("p",null,"在一次新生代GC回收后，如果对象还存活，则会进入S0或S1")]),l("li",null,[l("p",null,"之后，每经历过一次新生代回收，对象如果存活，它的年龄就会加一。")]),l("li",null,[l("p",null,"当对象的年龄达到一定条件后，就会被认为是老年代对象，从而进入老年代。")])],-1)),n[10]||(n[10]=l("h3",{id:"新生代",tabindex:"-1"},[a("新生代 "),l("a",{class:"header-anchor",href:"#新生代","aria-label":'Permalink to "新生代"'},"​")],-1)),n[11]||(n[11]=l("p",null,"存放新创建的对象， GC 频繁但快速",-1)),n[12]||(n[12]=l("ul",null,[l("li",null,[l("p",null,"Eden 区：新对象首先分配在这里")]),l("li",null,[l("p",null,"Survivor 区：两个大小相等的区域 S0、S1，用于存放 Eden 区 GC 后存活的对象")])],-1)),n[13]||(n[13]=l("h3",{id:"老年代",tabindex:"-1"},[a("老年代 "),l("a",{class:"header-anchor",href:"#老年代","aria-label":'Permalink to "老年代"'},"​")],-1)),n[14]||(n[14]=l("p",null,"存放长期存活的对象或大对象，如大数组",-1)),n[15]||(n[15]=l("p",null,"GC 频率低，但耗时长",-1)),n[16]||(n[16]=l("h2",{id:"方法区",tabindex:"-1"},[a("方法区 "),l("a",{class:"header-anchor",href:"#方法区","aria-label":'Permalink to "方法区"'},"​")],-1)),n[17]||(n[17]=l("p",null,"是 JVM 规范，所有虚拟机必须遵守",-1)),n[18]||(n[18]=l("ul",null,[l("li",null,[l("p",null,"线程共享")]),l("li",null,[l("p",null,"逻辑上属于堆，但不要求物理连续，也不一定在堆内")]),l("li",null,[l("p",null,"垃圾回收行为不确定，规范未强制要求 GC 方法区，但主流 JVM 会回收")]),l("li",null,[l("p",null,"内存不足会 OOM")])],-1)),n[19]||(n[19]=l("p",null,"方法区是 JVM 规范定义的概念，永久代/元空间都是其具体实现",-1)),n[20]||(n[20]=l("p",null,"保存内容：",-1)),n[21]||(n[21]=l("ul",null,[l("li",null,[l("p",null,"类的元数据，参考类加载流程中的加载部分。")]),l("li",null,[l("p",null,"运行时常量池 .class 文件中常量池的运行表示，如字面量、符号引用等")]),l("li",null,[l("p",null,"字段和方法数据")]),l("li",null,[l("p",null,"静态变量 类的 static 字段。JDK 7后，其本身在堆中，但其引用或元信息仍在方法区")]),l("li",null,[l("p",null,"JIT 编译后的代码缓存 热点方法被 JIT 编译为本地代码后缓存于此")])],-1)),n[22]||(n[22]=l("h3",{id:"实现",tabindex:"-1"},[a("实现 "),l("a",{class:"header-anchor",href:"#实现","aria-label":'Permalink to "实现"'},"​")],-1)),n[23]||(n[23]=l("ul",null,[l("li",null,[l("p",null,"永久代"),l("p",null,[a("JDK 7 以及之前使用永久代，位于堆内，受 "),l("code",null,"-Xmx"),a(" 限制。容易因动态生成类太多而 OOM。GC 不会在主程序运行期间对永久区域进行清理，Full GC 才会清理，因此容易因动态生成类太多而产生 OOM")])]),l("li",null,[l("p",null,"元空间 metasapce"),l("p",null,"不再位于堆中，而是使用操作系统本地内存。默认只受系统可用内存限制，降低 OOM 风险。但如果不指定最大大小，可能耗尽系统所有可用内存。")])],-1)),n[24]||(n[24]=l("p",null,"元空间的优势：",-1)),n[25]||(n[25]=l("ul",null,[l("li",null,[l("p",null,"不再位于 Java 堆，而是使用 操作系统本地内存（Native Memory）。")]),l("li",null,[l("p",null,"默认只受系统可用内存限制，大幅降低 OOM 风险。")]),l("li",null,[l("p",null,"类的元数据按类加载器隔离管理，卸载更高效。")]),l("li",null,[l("p",null,"支持更灵活的内存管理（如按类加载器释放）。")])],-1)),n[26]||(n[26]=l("h2",{id:"虚拟机栈与本地方法栈",tabindex:"-1"},[a("虚拟机栈与本地方法栈 "),l("a",{class:"header-anchor",href:"#虚拟机栈与本地方法栈","aria-label":'Permalink to "虚拟机栈与本地方法栈"'},"​")],-1)),n[27]||(n[27]=l("p",null,"存储 方法执行时的栈帧（Stack Frame），包括局部变量表、操作数栈、动态链接、方法返回地址等。",-1)),n[28]||(n[28]=l("p",null,"线程私有，生命周期与线程相同。由于私有，因此栈中的数据是线程安全的，无需同步。",-1)),n[29]||(n[29]=l("p",null,"栈帧是核心单位。每调用一个方法，就会创建一个栈帧并压入栈顶。方法执行完毕后，栈帧出栈。",-1)),n[30]||(n[30]=l("h3",{id:"局部变量表",tabindex:"-1"},[a("局部变量表 "),l("a",{class:"header-anchor",href:"#局部变量表","aria-label":'Permalink to "局部变量表"'},"​")],-1)),n[31]||(n[31]=l("p",null,[a("储存 "),l("code",null,"方法参数"),a(" 和方法内部的 "),l("code",null,"局部变量"),a(" 。大小在编译器确定。")],-1)),n[32]||(n[32]=l("h3",{id:"操作数栈",tabindex:"-1"},[a("操作数栈 "),l("a",{class:"header-anchor",href:"#操作数栈","aria-label":'Permalink to "操作数栈"'},"​")],-1)),n[33]||(n[33]=l("p",null,"用于保存中间计算结果，作为字节码指令的操作数。",-1)),n[34]||(n[34]=l("p",null,[a("例如：执行 "),l("code",null,"i = a + b"),a(" 时：")],-1)),n[35]||(n[35]=l("ol",null,[l("li",null,[a("先将 "),l("code",null,"a"),a("、"),l("code",null,"b"),a(" 压入操作数栈")]),l("li",null,[a("执行 "),l("code",null,"iadd"),a(" 指令，弹出两个值相加，结果再压入栈")]),l("li",null,[a("最后通过 "),l("code",null,"istore"),a(" 存入局部变量表")])],-1)),n[36]||(n[36]=l("p",null,[a("局部变量表和操作数栈都是栈帧中的 "),l("strong",null,"逻辑结构")],-1)),n[37]||(n[37]=l("h3",{id:"动态链接-常量池指针",tabindex:"-1"},[a("动态链接（常量池指针） "),l("a",{class:"header-anchor",href:"#动态链接-常量池指针","aria-label":'Permalink to "动态链接（常量池指针）"'},"​")],-1)),n[38]||(n[38]=l("p",null,"指向运行时常量池中该方法所属类的引用，用于支持方法调用过程中的符号解析",-1)),n[39]||(n[39]=l("h3",{id:"方法返回地址",tabindex:"-1"},[a("方法返回地址 "),l("a",{class:"header-anchor",href:"#方法返回地址","aria-label":'Permalink to "方法返回地址"'},"​")],-1)),n[40]||(n[40]=l("p",null,"当前方法执行完后，应该返回到调用者的哪条指令继续执行。正常返回或异常退出都会使用此信息。",-1)),n[41]||(n[41]=l("h3",{id:"本地方法栈",tabindex:"-1"},[a("本地方法栈 "),l("a",{class:"header-anchor",href:"#本地方法栈","aria-label":'Permalink to "本地方法栈"'},"​")],-1)),n[42]||(n[42]=l("p",null,"为 native 方法服务，与虚拟机栈类似。",-1)),n[43]||(n[43]=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"对比项"),l("th",null,"虚拟机栈"),l("th",null,"本地方法栈")])]),l("tbody",null,[l("tr",null,[l("td",null,"服务对象"),l("td",null,"Java 方法"),l("td",null,"Native 方法（C/C++ 编写）")]),l("tr",null,[l("td",null,"规范要求"),l("td",null,"必须支持"),l("td",null,"可自由实现（有些 JVM 合并两者）")]),l("tr",null,[l("td",null,"异常类型"),l("td",null,"StackOverflowError 等"),l("td",null,"类似，但取决于 native 实现")])])],-1)),n[44]||(n[44]=l("h2",{id:"程序计数器",tabindex:"-1"},[a("程序计数器 "),l("a",{class:"header-anchor",href:"#程序计数器","aria-label":'Permalink to "程序计数器"'},"​")],-1)),n[45]||(n[45]=l("p",null,"记录当前线程正在执行的字节码指令地址。如果是 native 方法，为 undefined.",-1)),n[46]||(n[46]=l("p",null,"线程私有；不会发生 OOM ; 字节码解释器通过改变 PC 值来选取下一条指令。",-1))]),"main-header":t(()=>[s(e.$slots,"main-header")]),"main-header-after":t(()=>[s(e.$slots,"main-header-after")]),"main-nav":t(()=>[s(e.$slots,"main-nav")]),"main-content-before":t(()=>[s(e.$slots,"main-content-before")]),"main-content":t(()=>[s(e.$slots,"main-content")]),"main-content-after":t(()=>[s(e.$slots,"main-content-after")]),"main-nav-before":t(()=>[s(e.$slots,"main-nav-before")]),"main-nav-after":t(()=>[s(e.$slots,"main-nav-after")]),comment:t(()=>[s(e.$slots,"comment")]),footer:t(()=>[s(e.$slots,"footer")]),aside:t(()=>[s(e.$slots,"aside")]),"aside-custom":t(()=>[s(e.$slots,"aside-custom")]),default:t(()=>[s(e.$slots,"default")]),_:3},8,["frontmatter"])}}};export{F as default,P as usePageData};
